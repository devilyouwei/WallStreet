{"code":"import * as tslib_1 from \"tslib\";\r\nimport { doc, serialization, Tensor, tidy, util } from '@tensorflow/tfjs-core';\r\nimport * as K from '../backend/tfjs_backend';\r\nimport { AttributeError, NotImplementedError, RuntimeError, ValueError } from '../errors';\r\nimport { deserialize as deserializeLayer } from '../layers/serialization';\r\nimport { SymbolicTensor } from '../types';\r\nimport * as generic_utils from '../utils/generic_utils';\r\nimport { convertTsToPythonic } from '../utils/serialization_utils';\r\nimport { batchGetValue, batchSetValue, LayerVariable } from '../variables';\r\nimport { version as layersVersion } from '../version';\r\nvar InputSpec = (function () {\r\n    function InputSpec(config) {\r\n        this.dtype = config.dtype;\r\n        this.shape = config.shape;\r\n        if (config.shape != null) {\r\n            this.ndim = config.shape.length;\r\n        }\r\n        else {\r\n            this.ndim = config.ndim;\r\n        }\r\n        this.maxNDim = config.maxNDim;\r\n        this.minNDim = config.minNDim;\r\n        this.axes = config.axes || {};\r\n    }\r\n    return InputSpec;\r\n}());\r\nexport { InputSpec };\r\nvar _nextNodeID = 0;\r\nvar Node = (function () {\r\n    function Node(config, callArgs) {\r\n        this.callArgs = callArgs;\r\n        this.id = _nextNodeID++;\r\n        this.outboundLayer = config.outboundLayer;\r\n        this.inboundLayers = config.inboundLayers;\r\n        this.nodeIndices = config.nodeIndices;\r\n        this.tensorIndices = config.tensorIndices;\r\n        this.inputTensors = config.inputTensors;\r\n        this.outputTensors = config.outputTensors;\r\n        this.inputMasks = config.inputMasks;\r\n        this.outputMasks = config.outputMasks;\r\n        this.inputShapes = config.inputShapes;\r\n        this.outputShapes = config.outputShapes;\r\n        for (var _i = 0, _a = config.inboundLayers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            if (layer != null) {\r\n                layer.outboundNodes.push(this);\r\n            }\r\n        }\r\n        config.outboundLayer.inboundNodes.push(this);\r\n    }\r\n    Node.prototype.getConfig = function () {\r\n        var inboundNames = [];\r\n        for (var _i = 0, _a = this.inboundLayers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            if (layer != null) {\r\n                inboundNames.push(layer.name);\r\n            }\r\n            else {\r\n                inboundNames.push(null);\r\n            }\r\n        }\r\n        return {\r\n            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,\r\n            inboundLayers: inboundNames,\r\n            nodeIndices: this.nodeIndices,\r\n            tensorIndices: this.tensorIndices\r\n        };\r\n    };\r\n    return Node;\r\n}());\r\nexport { Node };\r\nvar _nextLayerID = 0;\r\nvar Layer = (function (_super) {\r\n    tslib_1.__extends(Layer, _super);\r\n    function Layer(config) {\r\n        var _this = _super.call(this) || this;\r\n        _this._callHook = null;\r\n        _this._addedWeightNames = [];\r\n        _this._stateful = false;\r\n        _this.id = _nextLayerID++;\r\n        _this.activityRegularizer = null;\r\n        _this.inputSpec = null;\r\n        _this.supportsMasking = false;\r\n        _this._trainableWeights = [];\r\n        _this._nonTrainableWeights = [];\r\n        _this._losses = [];\r\n        _this._updates = [];\r\n        _this._built = false;\r\n        _this.inboundNodes = [];\r\n        _this.outboundNodes = [];\r\n        var name = config.name;\r\n        if (!name) {\r\n            var prefix = _this.getClassName();\r\n            name = generic_utils.toSnakeCase(prefix) + '_' + K.getUid(prefix);\r\n        }\r\n        _this.name = name;\r\n        _this.trainable = config.trainable == null ? true : config.trainable;\r\n        _this.updatable = config.updatable == null ? true : config.updatable;\r\n        if (config.inputShape != null || config.batchInputShape != null) {\r\n            var batchInputShape = void 0;\r\n            if (config.batchInputShape != null) {\r\n                batchInputShape = config.batchInputShape;\r\n            }\r\n            else if (config.inputShape != null) {\r\n                var batchSize = null;\r\n                if (config.batchSize != null) {\r\n                    batchSize = config.batchSize;\r\n                }\r\n                batchInputShape = [batchSize].concat(config.inputShape);\r\n            }\r\n            _this.batchInputShape = batchInputShape;\r\n            var dtype = config.dtype;\r\n            if (dtype == null) {\r\n                dtype = config.inputDType;\r\n            }\r\n            if (dtype == null) {\r\n                dtype = K.floatx();\r\n            }\r\n            _this.dtype = dtype;\r\n        }\r\n        if (config.weights != null) {\r\n            _this.initialWeights = config.weights;\r\n        }\r\n        else {\r\n            _this.initialWeights = null;\r\n        }\r\n        return _this;\r\n    }\r\n    Layer.nodeKey = function (layer, nodeIndex) {\r\n        return layer.name + '_ib-' + nodeIndex.toString();\r\n    };\r\n    Layer.prototype.getNodeAtIndex = function (nodeIndex, attrName) {\r\n        if (this.inboundNodes.length === 0) {\r\n            throw new RuntimeError('The layer has never been called ' +\r\n                (\"and thus has no defined \" + attrName + \".\"));\r\n        }\r\n        if (this.inboundNodes.length <= nodeIndex) {\r\n            throw new ValueError(\"Asked to get \" + attrName + \" at node \" + nodeIndex + \", \" +\r\n                (\"but the layer has only \" + this.inboundNodes.length + \" inbound nodes.\"));\r\n        }\r\n        return this.inboundNodes[nodeIndex];\r\n    };\r\n    Layer.prototype.getInputAt = function (nodeIndex) {\r\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'input').inputTensors);\r\n    };\r\n    Layer.prototype.getOutputAt = function (nodeIndex) {\r\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'output').outputTensors);\r\n    };\r\n    Object.defineProperty(Layer.prototype, \"input\", {\r\n        get: function () {\r\n            if (this.inboundNodes.length > 1) {\r\n                throw new AttributeError(\"Layer \" + this.name +\r\n                    ' has multiple inbound nodes, ' +\r\n                    'hence the notion of \"layer input\" ' +\r\n                    'is ill-defined. ' +\r\n                    'Use `getInputAt(nodeIndex)` instead.');\r\n            }\r\n            else if (this.inboundNodes.length === 0) {\r\n                throw new AttributeError(\"Layer \" + this.name +\r\n                    ' is not connected, no input to return.');\r\n            }\r\n            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'input').inputTensors);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"output\", {\r\n        get: function () {\r\n            if (this.inboundNodes.length === 0) {\r\n                throw new AttributeError(\"Layer \" + this.name +\r\n                    ' has no inbound nodes.');\r\n            }\r\n            if (this.inboundNodes.length > 1) {\r\n                throw new AttributeError(\"Layer \" + this.name +\r\n                    ' has multiple inbound nodes, ' +\r\n                    'hence the notion of \"layer output\" ' +\r\n                    'is ill-defined. ' +\r\n                    'Use `getOutputAt(nodeIndex)` instead.');\r\n            }\r\n            return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'output').outputTensors);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"losses\", {\r\n        get: function () {\r\n            return this._losses;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Layer.prototype.calculateLosses = function () {\r\n        return this.losses.map(function (lossFn) { return lossFn(); });\r\n    };\r\n    Object.defineProperty(Layer.prototype, \"updates\", {\r\n        get: function () {\r\n            return this._updates;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"built\", {\r\n        get: function () {\r\n            return this._built;\r\n        },\r\n        set: function (built) {\r\n            this._built = built;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"trainableWeights\", {\r\n        get: function () {\r\n            if (this.trainable) {\r\n                return this._trainableWeights;\r\n            }\r\n            else {\r\n                return [];\r\n            }\r\n        },\r\n        set: function (weights) {\r\n            this._trainableWeights = weights;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"nonTrainableWeights\", {\r\n        get: function () {\r\n            if (!this.trainable) {\r\n                return this._trainableWeights.concat(this._nonTrainableWeights);\r\n            }\r\n            else {\r\n                return this._nonTrainableWeights;\r\n            }\r\n        },\r\n        set: function (weights) {\r\n            this._nonTrainableWeights = weights;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"weights\", {\r\n        get: function () {\r\n            return this.trainableWeights.concat(this.nonTrainableWeights);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Layer.prototype, \"stateful\", {\r\n        get: function () {\r\n            return this._stateful;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Layer.prototype.assertInputCompatibility = function (inputs) {\r\n        inputs = generic_utils.toList(inputs);\r\n        if (this.inputSpec == null || this.inputSpec.length === 0) {\r\n            return;\r\n        }\r\n        var inputSpec = generic_utils.toList(this.inputSpec);\r\n        if (inputs.length !== inputSpec.length) {\r\n            throw new ValueError(\"Layer \" + this.name + \" expects \" + inputSpec.length + \" inputs, \" +\r\n                (\"but it received \" + inputs.length + \" input tensors. \") +\r\n                (\"Input received: \" + inputs));\r\n        }\r\n        for (var inputIndex = 0; inputIndex < inputs.length; inputIndex++) {\r\n            var x = inputs[inputIndex];\r\n            var spec = inputSpec[inputIndex];\r\n            if (spec == null) {\r\n                continue;\r\n            }\r\n            var ndim = x.rank;\r\n            if (spec.ndim != null) {\r\n                if (ndim !== spec.ndim) {\r\n                    throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" + this.name + \": \" +\r\n                        (\"expected ndim=\" + spec.ndim + \", found ndim=\" + ndim));\r\n                }\r\n            }\r\n            if (spec.maxNDim != null) {\r\n                if (ndim > spec.maxNDim) {\r\n                    throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" + this.name +\r\n                        (\": expected max_ndim=\" + spec.maxNDim + \", found ndim=\" + ndim));\r\n                }\r\n            }\r\n            if (spec.minNDim != null) {\r\n                if (ndim < spec.minNDim) {\r\n                    throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" + this.name +\r\n                        (\": expected min_ndim=\" + spec.minNDim + \", found ndim=\" + ndim + \".\"));\r\n                }\r\n            }\r\n            if (spec.dtype != null) {\r\n                if (K.dtype(x) !== spec.dtype) {\r\n                    var xDType = K.dtype(x);\r\n                    throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" + this.name + \" \" +\r\n                        (\": expected dtype=\" + spec.dtype + \", found dtype=\" + xDType + \".\"));\r\n                }\r\n            }\r\n            if (spec.axes) {\r\n                var xShape = K.intShape(x);\r\n                for (var key in spec.axes) {\r\n                    var axis = Number(key);\r\n                    var value = spec.axes[key];\r\n                    var xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];\r\n                    if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {\r\n                        throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" +\r\n                            (this.name + \": expected axis \" + axis + \" of input shape to \") +\r\n                            (\"have value \" + value + \" but got shape \" + xShape + \".\"));\r\n                    }\r\n                }\r\n            }\r\n            if (spec.shape != null) {\r\n                var xShape = K.intShape(x);\r\n                for (var i = 0; i < spec.shape.length; ++i) {\r\n                    var specDim = spec.shape[i];\r\n                    var dim = xShape[i];\r\n                    if (specDim != null && dim != null) {\r\n                        if (specDim !== dim) {\r\n                            throw new ValueError(\"Input \" + inputIndex + \" is incompatible with layer \" +\r\n                                (this.name + \": expected shape=\" + spec.shape + \", \") +\r\n                                'found shape=${xShape}.');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Layer.prototype.call = function (inputs, kwargs) {\r\n        return inputs;\r\n    };\r\n    Layer.prototype.invokeCallHook = function (inputs, kwargs) {\r\n        if (this._callHook != null) {\r\n            this._callHook(inputs, kwargs);\r\n        }\r\n    };\r\n    Layer.prototype.setCallHook = function (callHook) {\r\n        this._callHook = callHook;\r\n    };\r\n    Layer.prototype.clearCallHook = function () {\r\n        this._callHook = null;\r\n    };\r\n    Layer.prototype.apply = function (inputs, kwargs) {\r\n        var _this = this;\r\n        kwargs = kwargs || {};\r\n        var inputsList = generic_utils.toList(inputs);\r\n        var allAreSymbolic = true;\r\n        for (var _i = 0, inputsList_1 = inputsList; _i < inputsList_1.length; _i++) {\r\n            var input = inputsList_1[_i];\r\n            if (!(input instanceof SymbolicTensor)) {\r\n                allAreSymbolic = false;\r\n                break;\r\n            }\r\n        }\r\n        var noneAreSymbolic = true;\r\n        for (var _a = 0, inputsList_2 = inputsList; _a < inputsList_2.length; _a++) {\r\n            var input = inputsList_2[_a];\r\n            if (input instanceof SymbolicTensor) {\r\n                noneAreSymbolic = false;\r\n                break;\r\n            }\r\n        }\r\n        if (allAreSymbolic === noneAreSymbolic) {\r\n            throw new ValueError('Arguments to apply() must be all ' +\r\n                'SymbolicTensors or all Tensors');\r\n        }\r\n        return K.nameScope(this.name, function () {\r\n            if (!_this.built) {\r\n                _this.assertInputCompatibility(inputs);\r\n                var inputShapes = [];\r\n                for (var _i = 0, _a = generic_utils.toList(inputs); _i < _a.length; _i++) {\r\n                    var xElem = _a[_i];\r\n                    inputShapes.push(K.intShape(xElem));\r\n                }\r\n                _this.build(generic_utils.singletonOrArray(inputShapes));\r\n                _this.built = true;\r\n                if (_this.initialWeights) {\r\n                    _this.setWeights(_this.initialWeights);\r\n                }\r\n            }\r\n            _this.assertInputCompatibility(inputs);\r\n            if (noneAreSymbolic) {\r\n                var output = _this.call(inputs, kwargs);\r\n                var outputList = generic_utils.toList(output);\r\n                var outputListCopy = [];\r\n                for (var _b = 0, outputList_1 = outputList; _b < outputList_1.length; _b++) {\r\n                    var x = outputList_1[_b];\r\n                    if (inputsList.indexOf(x) !== -1) {\r\n                        x = K.identity(x);\r\n                    }\r\n                    outputListCopy.push(x);\r\n                }\r\n                output = generic_utils.singletonOrArray(outputListCopy);\r\n                if (_this.activityRegularizer != null) {\r\n                    throw new NotImplementedError('Layer invocation in the presence of activity ' +\r\n                        'regularizer(s) is not supported yet.');\r\n                }\r\n                return output;\r\n            }\r\n            else {\r\n                var inputShape = collectInputShape(inputs);\r\n                var outputShape = _this.computeOutputShape(inputShape);\r\n                var output = void 0;\r\n                var outputDType_1 = guessOutputDType(inputs);\r\n                if (outputShape != null && outputShape.length > 0 &&\r\n                    Array.isArray(outputShape[0])) {\r\n                    output = outputShape\r\n                        .map(function (shape, index) { return new SymbolicTensor(outputDType_1, shape, _this, generic_utils.toList(inputs), kwargs, _this.name, index); });\r\n                }\r\n                else {\r\n                    output = new SymbolicTensor(outputDType_1, outputShape, _this, generic_utils.toList(inputs), kwargs, _this.name);\r\n                }\r\n                _this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);\r\n                if (_this.activityRegularizer != null) {\r\n                    throw new NotImplementedError('Layer invocation in the presence of activity ' +\r\n                        'regularizer(s) is not supported yet.');\r\n                }\r\n                return output;\r\n            }\r\n        });\r\n    };\r\n    Layer.prototype.build = function (inputShape) {\r\n        this.built = true;\r\n    };\r\n    Layer.prototype.getWeights = function (trainableOnly) {\r\n        if (trainableOnly === void 0) { trainableOnly = false; }\r\n        return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);\r\n    };\r\n    Layer.prototype.setWeights = function (weights) {\r\n        var _this = this;\r\n        tidy(function () {\r\n            var params = _this.weights;\r\n            if (params.length !== weights.length) {\r\n                throw new ValueError(\"You called setWeights(weights) on layer \\\"\" + _this.name + \"\\\" \" +\r\n                    (\"with a weight list of length \" + weights.length + \", \") +\r\n                    (\"but the layer was expecting \" + params.length + \" weights. \") +\r\n                    (\"Provided weights: \" + weights + \"...\"));\r\n            }\r\n            if (params.length === 0) {\r\n                return;\r\n            }\r\n            var weightValueTuples = [];\r\n            var paramValues = batchGetValue(params);\r\n            for (var i = 0; i < paramValues.length; ++i) {\r\n                var pv = paramValues[i];\r\n                var p = params[i];\r\n                var w = weights[i];\r\n                if (!util.arraysEqual(pv.shape, w.shape)) {\r\n                    throw new ValueError(\"Layer weight shape \" + pv.shape + \" \" +\r\n                        (\"not compatible with provided weight shape \" + w.shape));\r\n                }\r\n                weightValueTuples.push([p, w]);\r\n            }\r\n            batchSetValue(weightValueTuples);\r\n        });\r\n    };\r\n    Layer.prototype.addWeight = function (name, shape, dtype, initializer, regularizer, trainable, constraint) {\r\n        if (this._addedWeightNames.indexOf(name) !== -1) {\r\n            throw new ValueError(\"Duplicate weight name \" + name + \" for layer \" + this.name);\r\n        }\r\n        this._addedWeightNames.push(name);\r\n        if (dtype == null) {\r\n            dtype = K.floatx();\r\n        }\r\n        var weight = new LayerVariable(initializer.apply(shape, dtype), dtype, name, trainable, constraint);\r\n        if (regularizer != null) {\r\n            this.addLoss(function () { return regularizer.apply(weight.read()); });\r\n        }\r\n        if (trainable == null) {\r\n            trainable = true;\r\n        }\r\n        if (trainable) {\r\n            this._trainableWeights.push(weight);\r\n        }\r\n        else {\r\n            this._nonTrainableWeights.push(weight);\r\n        }\r\n        return weight;\r\n    };\r\n    Layer.prototype.addLoss = function (losses) {\r\n        if (losses == null || Array.isArray(losses) && losses.length === 0) {\r\n            return;\r\n        }\r\n        losses = generic_utils.toList(losses);\r\n        if (this._losses !== undefined && this._losses !== null) {\r\n            (_a = this.losses).push.apply(_a, losses);\r\n        }\r\n        var _a;\r\n    };\r\n    Layer.prototype.computeOutputShape = function (inputShape) {\r\n        return inputShape;\r\n    };\r\n    Layer.prototype.computeMask = function (inputs, mask) {\r\n        var _this = this;\r\n        if (!this.supportsMasking) {\r\n            if (mask != null) {\r\n                if (Array.isArray(mask)) {\r\n                    mask.forEach(function (maskElement) {\r\n                        if (maskElement != null) {\r\n                            throw new TypeError(\"Layer \" + _this.name + \" does not support masking,\" +\r\n                                'but was passed an inputMask.');\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    throw new TypeError(\"Layer \" + this.name + \" does not support masking,\" +\r\n                        'but was passed an inputMask.');\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        return mask;\r\n    };\r\n    Layer.prototype.addInboundNode = function (inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs) {\r\n        if (kwargs === void 0) { kwargs = null; }\r\n        var inputTensorList = generic_utils.toList(inputTensors);\r\n        outputTensors = generic_utils.toList(outputTensors);\r\n        inputMasks = generic_utils.toList(inputMasks);\r\n        outputMasks = generic_utils.toList(outputMasks);\r\n        inputShapes = generic_utils.normalizeShapeList(inputShapes);\r\n        outputShapes = generic_utils.normalizeShapeList(outputShapes);\r\n        var inboundLayers = [];\r\n        var nodeIndices = [];\r\n        var tensorIndices = [];\r\n        for (var _i = 0, inputTensorList_1 = inputTensorList; _i < inputTensorList_1.length; _i++) {\r\n            var x = inputTensorList_1[_i];\r\n            inboundLayers.push(x.sourceLayer);\r\n            nodeIndices.push(x.nodeIndex);\r\n            tensorIndices.push(x.tensorIndex);\r\n        }\r\n        new Node({\r\n            outboundLayer: this,\r\n            inboundLayers: inboundLayers,\r\n            nodeIndices: nodeIndices,\r\n            tensorIndices: tensorIndices,\r\n            inputTensors: inputTensorList,\r\n            outputTensors: outputTensors,\r\n            inputMasks: inputMasks,\r\n            outputMasks: outputMasks,\r\n            inputShapes: inputShapes,\r\n            outputShapes: outputShapes\r\n        }, kwargs);\r\n        for (var i = 0; i < outputTensors.length; i++) {\r\n            outputTensors[i].sourceLayer = this;\r\n            outputTensors[i].nodeIndex = this.inboundNodes.length - 1;\r\n            outputTensors[i].tensorIndex = i;\r\n        }\r\n    };\r\n    Layer.prototype.getConfig = function () {\r\n        var config = { name: this.name, trainable: this.trainable };\r\n        if (this.batchInputShape != null) {\r\n            config['batchInputShape'] = this.batchInputShape;\r\n        }\r\n        if (this.dtype != null) {\r\n            config['dtype'] = this.dtype;\r\n        }\r\n        return config;\r\n    };\r\n    tslib_1.__decorate([\r\n        doc({ heading: 'Models', 'subheading': 'Classes' })\r\n    ], Layer.prototype, \"apply\", null);\r\n    Layer = tslib_1.__decorate([\r\n        doc({ heading: 'Layers', subheading: 'Classes', namespace: 'layers' })\r\n    ], Layer);\r\n    return Layer;\r\n}(serialization.Serializable));\r\nexport { Layer };\r\nfunction collectInputShape(inputTensors) {\r\n    inputTensors =\r\n        generic_utils.toList(inputTensors);\r\n    var shapes = [];\r\n    for (var _i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {\r\n        var x = inputTensors_1[_i];\r\n        shapes.push(K.intShape(x));\r\n    }\r\n    return generic_utils.singletonOrArray(shapes);\r\n}\r\nfunction guessOutputDType(inputTensors) {\r\n    return 'float32';\r\n}\r\nvar InputLayer = (function (_super) {\r\n    tslib_1.__extends(InputLayer, _super);\r\n    function InputLayer(config) {\r\n        var _this = _super.call(this, {\r\n            dtype: config.dtype,\r\n            name: config.name != null ? config.name : K.getUid('input').toString()\r\n        }) || this;\r\n        if (config.batchSize == null) {\r\n            config.batchSize = null;\r\n        }\r\n        if (config.sparse == null) {\r\n            config.sparse = false;\r\n        }\r\n        _this.trainable = false;\r\n        _this.built = true;\r\n        _this.sparse = config.sparse;\r\n        if (config.inputShape != null && config.batchInputShape != null) {\r\n            throw new ValueError('Only provide the inputShape OR ' +\r\n                'batchInputShape argument to inputLayer, not both at the same time.');\r\n        }\r\n        var batchInputShape = config.batchInputShape;\r\n        if (batchInputShape == null) {\r\n            if (config.inputShape == null) {\r\n                throw new ValueError('An InputLayer should be passed either a ' +\r\n                    '`batchInputShape` or an `inputShape`.');\r\n            }\r\n            else {\r\n                batchInputShape = [config.batchSize].concat(config.inputShape);\r\n            }\r\n        }\r\n        else {\r\n            if (config.batchSize != null) {\r\n                throw new ValueError('Cannot specify batchSize if batchInputShape is' +\r\n                    'specified when creating an InputLayer.');\r\n            }\r\n        }\r\n        var dtype = config.dtype || K.floatx();\r\n        _this.batchInputShape = batchInputShape;\r\n        _this.dtype = dtype;\r\n        _this.inputSpec = [{ shape: batchInputShape }];\r\n        var inputTensor = new SymbolicTensor(_this.dtype, _this.batchInputShape, _this, [], {}, _this.name);\r\n        inputTensor.nodeIndex = 0;\r\n        inputTensor.tensorIndex = 0;\r\n        new Node({\r\n            outboundLayer: _this,\r\n            inboundLayers: [],\r\n            nodeIndices: [],\r\n            tensorIndices: [],\r\n            inputTensors: [inputTensor],\r\n            outputTensors: [inputTensor],\r\n            inputMasks: [null],\r\n            outputMasks: [null],\r\n            inputShapes: [batchInputShape],\r\n            outputShapes: [batchInputShape]\r\n        });\r\n        return _this;\r\n    }\r\n    InputLayer.prototype.apply = function (inputs, kwargs) {\r\n        throw new ValueError('Cannot pass any input to an ' +\r\n            (\"InputLayer's apply() method. InputLayer name: \" + this.name));\r\n    };\r\n    InputLayer.prototype.getConfig = function () {\r\n        return {\r\n            batchInputShape: this.batchInputShape,\r\n            dtype: this.dtype,\r\n            sparse: this.sparse,\r\n            name: this.name\r\n        };\r\n    };\r\n    InputLayer.className = 'InputLayer';\r\n    return InputLayer;\r\n}(Layer));\r\nexport { InputLayer };\r\nserialization.SerializationMap.register(InputLayer);\r\nexport function Input(config) {\r\n    if (config.batchShape == null && config.shape == null) {\r\n        throw new Error('Please provide to Input either a `shape`' +\r\n            ' or a `batchShape` argument. Note that ' +\r\n            '`shape` does not include the batch ' +\r\n            'dimension.');\r\n    }\r\n    if (config.batchShape != null && config.shape != null) {\r\n        throw new ValueError('Please provide either a `shape` or `batchShape` ' +\r\n            'argument to Input, but not both.');\r\n    }\r\n    var batchShape = config.batchShape;\r\n    if (config.shape != null && batchShape == null) {\r\n        batchShape = [null].concat(config.shape);\r\n    }\r\n    var dtype = config.dtype;\r\n    if (dtype == null) {\r\n        dtype = K.floatx();\r\n    }\r\n    var inputLayer = new InputLayer({\r\n        batchInputShape: batchShape,\r\n        name: config.name,\r\n        dtype: dtype,\r\n        sparse: config.sparse\r\n    });\r\n    var outputs = inputLayer.inboundNodes[0].outputTensors;\r\n    return outputs[0];\r\n}\r\nvar Container = (function (_super) {\r\n    tslib_1.__extends(Container, _super);\r\n    function Container(config) {\r\n        var _this = _super.call(this, {}) || this;\r\n        _this.containerNodes = new Set();\r\n        _this.name = config.name;\r\n        if (_this.name == null) {\r\n            var prefix = _this.getClassName().toLowerCase();\r\n            _this.name = K.getUid(prefix);\r\n        }\r\n        _this.supportsMasking = false;\r\n        _this.trainable = true;\r\n        _this.updatable = true;\r\n        if (Array.isArray(config.inputs)) {\r\n            _this.inputs = config.inputs.slice();\r\n        }\r\n        else {\r\n            _this.inputs = [config.inputs];\r\n        }\r\n        if (Array.isArray(config.outputs)) {\r\n            _this.outputs = config.outputs.slice();\r\n        }\r\n        else {\r\n            _this.outputs = [config.outputs];\r\n        }\r\n        if (generic_utils.unique(_this.inputs).length !== _this.inputs.length) {\r\n            throw new ValueError('The list of inputs passed to the model is ' +\r\n                'redundant. All inputs should only appear once. Found: ' +\r\n                _this.inputs.map(function (x) { return x.name; }));\r\n        }\r\n        if (generic_utils.unique(_this.outputs).length !== _this.outputs.length) {\r\n            console.warn('The list of outputs passed to the model is redundant. ' +\r\n                'All outputs should only appear once. Found: ' +\r\n                _this.outputs.map(function (x) { return x.name; }));\r\n        }\r\n        _this.inputLayers = [];\r\n        _this.inputLayersNodeIndices = [];\r\n        _this.inputLayersTensorIndices = [];\r\n        _this.outputLayers = [];\r\n        _this.outputLayersNodeIndices = [];\r\n        _this.outputLayersTensorIndices = [];\r\n        _this.layers = [];\r\n        for (var _i = 0, _a = _this.outputs; _i < _a.length; _i++) {\r\n            var x = _a[_i];\r\n            var layer = x.sourceLayer;\r\n            var nodeIndex = x.nodeIndex;\r\n            var tensorIndex = x.tensorIndex;\r\n            _this.outputLayers.push(layer);\r\n            _this.outputLayersNodeIndices.push(nodeIndex);\r\n            _this.outputLayersTensorIndices.push(tensorIndex);\r\n        }\r\n        for (var _b = 0, _c = _this.inputs; _b < _c.length; _b++) {\r\n            var x = _c[_b];\r\n            var layer = x.sourceLayer;\r\n            var nodeIndex = x.nodeIndex;\r\n            var tensorIndex = x.tensorIndex;\r\n            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');\r\n            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');\r\n            _this.inputLayers.push(layer);\r\n            _this.inputLayersNodeIndices.push(nodeIndex);\r\n            _this.inputLayersTensorIndices.push(tensorIndex);\r\n        }\r\n        _this.inputNames = [];\r\n        _this.outputNames = [];\r\n        _this.feedInputShapes = [];\r\n        _this.feedInputNames = [];\r\n        _this.feedOutputNames = [];\r\n        for (var i = 0; i < _this.inputLayers.length; i++) {\r\n            var layer = _this.inputLayers[i];\r\n            if (!(layer instanceof InputLayer)) {\r\n                throw new TypeError('Input layers to a Model must be InputLayer objects. ' +\r\n                    (\"Received inputs: \" + config.inputs + \". \") +\r\n                    (\"Input \" + i + \" (0-based) originates \") +\r\n                    (\"from layer type \" + layer.getClassName() + \".\"));\r\n            }\r\n            _this.inputNames.push(layer.name);\r\n            _this.feedInputShapes.push(layer.batchInputShape);\r\n            _this.feedInputNames.push(layer.name);\r\n        }\r\n        for (var _d = 0, _e = _this.outputLayers; _d < _e.length; _d++) {\r\n            var layer = _e[_d];\r\n            _this.outputNames.push(layer.name);\r\n        }\r\n        _this.internalInputShapes = _this.inputs.map(function (x) { return x.shape; });\r\n        _this.internalOutputShapes = _this.outputs.map(function (x) { return x.shape; });\r\n        var nodesDepths = {};\r\n        var nodeIDToNode = {};\r\n        var layersDepths = {};\r\n        var layerIDToLayer = {};\r\n        var layerIndices = {};\r\n        var nodesInDecreasingDepth = [];\r\n        var buildMapOfGraph = function (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) {\r\n            if (layer == null || nodeIndex == null || tensorIndex == null) {\r\n                layer = tensor.sourceLayer;\r\n                nodeIndex = tensor.nodeIndex;\r\n                tensorIndex = tensor.tensorIndex;\r\n            }\r\n            var node = layer.inboundNodes[nodeIndex];\r\n            if (nodesInProgress.indexOf(node) !== -1) {\r\n                throw new RuntimeError(\"The tensor \" + tensor.name + \" at layer \\\"\" + layer.name + \"\\\" \" +\r\n                    'is part of a cycle.');\r\n            }\r\n            if (finishedNodes.indexOf(node) !== -1) {\r\n                return;\r\n            }\r\n            _this.containerNodes.add(Container.nodeKey(layer, nodeIndex));\r\n            if (!(layer.id in layerIndices)) {\r\n                layerIndices[layer.id] = Object.keys(layerIndices).length;\r\n            }\r\n            if (nodesInProgress.indexOf(node) === -1) {\r\n                nodesInProgress.push(node);\r\n            }\r\n            var numInboundLayers = node.inboundLayers.length;\r\n            for (var i = 0; i < numInboundLayers; i++) {\r\n                var x = node.inputTensors[i];\r\n                var layer_1 = node.inboundLayers[i];\r\n                var nodeIndex_1 = node.nodeIndices[i];\r\n                var tensorIndex_1 = node.tensorIndices[i];\r\n                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer_1, nodeIndex_1, tensorIndex_1);\r\n            }\r\n            finishedNodes.push(node);\r\n            while (nodesInProgress.indexOf(node) >= 0) {\r\n                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);\r\n            }\r\n            nodesInDecreasingDepth.push(node);\r\n        };\r\n        var finishedNodes = [];\r\n        var nodesInProgress = [];\r\n        for (var _f = 0, _g = _this.outputs; _f < _g.length; _f++) {\r\n            var x = _g[_f];\r\n            buildMapOfGraph(x, finishedNodes, nodesInProgress);\r\n        }\r\n        var reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();\r\n        for (var _h = 0, reversedNodesInDecreasingDepth_1 = reversedNodesInDecreasingDepth; _h < reversedNodesInDecreasingDepth_1.length; _h++) {\r\n            var node = reversedNodesInDecreasingDepth_1[_h];\r\n            nodeIDToNode[node.id] = node;\r\n            if (!(node.id in nodesDepths)) {\r\n                nodesDepths[node.id] = 0;\r\n            }\r\n            var depth = nodesDepths[node.id];\r\n            var previousDepth = (layersDepths[node.outboundLayer.id] == null ?\r\n                0 :\r\n                layersDepths[node.outboundLayer.id]);\r\n            depth = Math.max(depth, previousDepth);\r\n            layersDepths[node.outboundLayer.id] = depth;\r\n            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;\r\n            nodesDepths[node.id] = depth;\r\n            for (var i = 0; i < node.inboundLayers.length; i++) {\r\n                var inboundLayer = node.inboundLayers[i];\r\n                var nodeIndex = node.nodeIndices[i];\r\n                var inboundNode = inboundLayer.inboundNodes[nodeIndex];\r\n                var previousDepth_1 = (nodesDepths[inboundNode.id] == null ? 0 :\r\n                    nodesDepths[inboundNode.id]);\r\n                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth_1);\r\n                nodeIDToNode[inboundNode.id] = inboundNode;\r\n            }\r\n        }\r\n        var nodesByDepth = {};\r\n        for (var nodeID in nodesDepths) {\r\n            var depth = nodesDepths[nodeID];\r\n            if (!(depth in nodesByDepth)) {\r\n                nodesByDepth[depth] = [];\r\n            }\r\n            nodesByDepth[depth].push(nodeIDToNode[nodeID]);\r\n        }\r\n        var layersByDepth = {};\r\n        for (var layerID in layersDepths) {\r\n            var depth = layersDepths[layerID];\r\n            if (!(depth in layersByDepth)) {\r\n                layersByDepth[depth] = [];\r\n            }\r\n            layersByDepth[depth].push(layerIDToLayer[layerID]);\r\n        }\r\n        var depthKeys = Object.keys(layersByDepth)\r\n            .map(function (x) { return parseInt(x, 10); })\r\n            .sort(generic_utils.reverseNumberCompare);\r\n        _this.layers = [];\r\n        for (var _j = 0, depthKeys_1 = depthKeys; _j < depthKeys_1.length; _j++) {\r\n            var depth = depthKeys_1[_j];\r\n            var layersForDepth = layersByDepth[depth];\r\n            layersForDepth.sort(function (a, b) {\r\n                var aIndex = layerIndices[a.id];\r\n                var bIndex = layerIndices[b.id];\r\n                if (aIndex < bIndex) {\r\n                    return -1;\r\n                }\r\n                if (aIndex > bIndex) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            });\r\n            for (var _k = 0, layersForDepth_1 = layersForDepth; _k < layersForDepth_1.length; _k++) {\r\n                var layer = layersForDepth_1[_k];\r\n                _this.layers.push(layer);\r\n            }\r\n        }\r\n        _this.layersByDepth = layersByDepth;\r\n        depthKeys = Object.keys(nodesByDepth)\r\n            .map(function (x) { return parseInt(x, 10); })\r\n            .sort(generic_utils.reverseNumberCompare);\r\n        var computableTensors = _this.inputs.slice();\r\n        var layersWithCompleteInput = [];\r\n        for (var _l = 0, depthKeys_2 = depthKeys; _l < depthKeys_2.length; _l++) {\r\n            var depth = depthKeys_2[_l];\r\n            for (var _m = 0, _o = nodesByDepth[depth]; _m < _o.length; _m++) {\r\n                var node = _o[_m];\r\n                var layer = node.outboundLayer;\r\n                if (layer != null) {\r\n                    for (var _p = 0, _q = node.inputTensors; _p < _q.length; _p++) {\r\n                        var x = _q[_p];\r\n                        if (computableTensors.indexOf(x) === -1) {\r\n                            throw new RuntimeError(\"Graph disconnected: cannot obtain value for tensor \" + x +\r\n                                (\" at layer \\\"\" + layer.name + \"\\\". \") +\r\n                                'The following previous layers were accessed without ' +\r\n                                (\"issue: \" + layersWithCompleteInput));\r\n                        }\r\n                    }\r\n                    for (var _r = 0, _s = node.outputTensors; _r < _s.length; _r++) {\r\n                        var x = _s[_r];\r\n                        computableTensors.push(x);\r\n                    }\r\n                    layersWithCompleteInput.push(layer.name);\r\n                }\r\n            }\r\n        }\r\n        _this.nodesByDepth = nodesByDepth;\r\n        var allNames = _this.layers.map(function (x) { return x.name; });\r\n        var _loop_1 = function (name_1) {\r\n            var numOccurrences = allNames.filter(function (x) { return x === name_1; }).length;\r\n            if (numOccurrences !== 1) {\r\n                throw new RuntimeError(\"The name \\\"\" + name_1 + \"\\\" is used \" + numOccurrences + \" times \" +\r\n                    'in the model. All layer names should be unique. Layer names: ' +\r\n                    JSON.stringify(allNames));\r\n            }\r\n        };\r\n        for (var _t = 0, allNames_1 = allNames; _t < allNames_1.length; _t++) {\r\n            var name_1 = allNames_1[_t];\r\n            _loop_1(name_1);\r\n        }\r\n        _this.outboundNodes = [];\r\n        _this.inboundNodes = [];\r\n        new Node({\r\n            outboundLayer: _this,\r\n            inboundLayers: [],\r\n            nodeIndices: [],\r\n            tensorIndices: [],\r\n            inputTensors: _this.inputs,\r\n            outputTensors: _this.outputs,\r\n            inputMasks: _this.inputs.map(function (x) { return null; }),\r\n            outputMasks: _this.outputs.map(function (x) { return null; }),\r\n            inputShapes: _this.inputs.map(function (x) { return x.shape; }),\r\n            outputShapes: _this.outputs.map(function (x) { return x.shape; })\r\n        });\r\n        _this.built = true;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Container.prototype, \"trainableWeights\", {\r\n        get: function () {\r\n            if (this._trainableWeights.length > 0) {\r\n                throw new ValueError('Container instance unexpectedly contains _trainableWeights.' +\r\n                    'The trainable weights of a Container are a union of the ' +\r\n                    'trainable weights of its consituent Layers. Its own ' +\r\n                    '_trainableWeights must remain an empty Array.');\r\n            }\r\n            if (!this.trainable) {\r\n                return [];\r\n            }\r\n            var weights = [];\r\n            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n                var layer = _a[_i];\r\n                weights = weights.concat(layer.trainableWeights);\r\n            }\r\n            return weights;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Container.prototype, \"nonTrainableWeights\", {\r\n        get: function () {\r\n            var weights = [];\r\n            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n                var layer = _a[_i];\r\n                weights.push.apply(weights, layer.nonTrainableWeights);\r\n            }\r\n            if (!this.trainable) {\r\n                var trainableWeights = [];\r\n                for (var _b = 0, _c = this.layers; _b < _c.length; _b++) {\r\n                    var layer = _c[_b];\r\n                    trainableWeights.push.apply(trainableWeights, layer.trainableWeights);\r\n                }\r\n                return trainableWeights.concat(weights);\r\n            }\r\n            return weights;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Container.prototype, \"weights\", {\r\n        get: function () {\r\n            return this.trainableWeights.concat(this.nonTrainableWeights);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Container.prototype.loadWeights = function (weightsJSON, skipMismatch, isNamedTensorMap) {\r\n        if (skipMismatch === void 0) { skipMismatch = false; }\r\n        if (isNamedTensorMap === void 0) { isNamedTensorMap = false; }\r\n        if (isNamedTensorMap) {\r\n            loadWeightsFromNamedTensorMap(weightsJSON, this.layers);\r\n        }\r\n        else {\r\n            loadWeightsFromJson(weightsJSON, this.layers, skipMismatch);\r\n        }\r\n    };\r\n    Container.prototype.updatedConfig = function () {\r\n        var theConfig = this.getConfig();\r\n        var modelConfig = {\r\n            className: this.getClassName(),\r\n            config: theConfig,\r\n            kerasVersion: \"tfjs-layers \" + layersVersion,\r\n            backend: 'TensorFlow.js'\r\n        };\r\n        return modelConfig;\r\n    };\r\n    Container.prototype.toJSON = function (unused, returnString) {\r\n        if (returnString === void 0) { returnString = true; }\r\n        var modelConfig = convertTsToPythonic(this.updatedConfig());\r\n        return returnString ? JSON.stringify(modelConfig) : modelConfig;\r\n    };\r\n    Container.prototype.call = function (inputs, kwargs) {\r\n        var _this = this;\r\n        return tidy(function () {\r\n            inputs = generic_utils.toList(inputs);\r\n            var masks;\r\n            if ('mask' in kwargs) {\r\n                masks = generic_utils.toList(kwargs['mask']);\r\n            }\r\n            else {\r\n                masks = generic_utils.pyListRepeat(null, inputs.length);\r\n            }\r\n            return _this.runInternalGraph(inputs, masks)[0];\r\n        });\r\n    };\r\n    Container.prototype.computeMask = function (inputs, mask) {\r\n        var _this = this;\r\n        return tidy(function () {\r\n            inputs = generic_utils.toList(inputs);\r\n            var masks;\r\n            if (mask == null) {\r\n                masks = generic_utils.pyListRepeat(null, inputs.length);\r\n            }\r\n            else {\r\n                masks = generic_utils.toList(mask);\r\n            }\r\n            return _this.runInternalGraph(inputs, masks)[1];\r\n        });\r\n    };\r\n    Container.prototype.computeOutputShape = function (inputShape) {\r\n        var inputShapes = generic_utils.normalizeShapeList(inputShape);\r\n        if (inputShapes.length !== this.inputLayers.length) {\r\n            throw new ValueError(\"Invalid inputShape argument \" + inputShape + \": \" +\r\n                (\"model has \" + this.inputLayers.length + \" tensor inputs.\"));\r\n        }\r\n        var layersToOutputShapes = {};\r\n        for (var i = 0; i < inputShapes.length; i++) {\r\n            var layer = this.inputLayers[i];\r\n            var inputShape_1 = inputShapes[i];\r\n            var shapeKey = layer.name + '_0_0';\r\n            layersToOutputShapes[shapeKey] = inputShape_1;\r\n        }\r\n        var depthKeys = Object.keys(this.nodesByDepth)\r\n            .map(function (x) { return parseInt(x, 10); })\r\n            .sort(generic_utils.reverseNumberCompare);\r\n        if (depthKeys.length > 1) {\r\n            for (var _i = 0, depthKeys_3 = depthKeys; _i < depthKeys_3.length; _i++) {\r\n                var depth = depthKeys_3[_i];\r\n                var nodes = this.nodesByDepth[depth];\r\n                for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\r\n                    var node = nodes_1[_a];\r\n                    var layer = node.outboundLayer;\r\n                    if (this.inputLayers.map(function (x) { return x.id; }).indexOf(layer.id) !== -1) {\r\n                        continue;\r\n                    }\r\n                    var inputShapes_1 = [];\r\n                    for (var j = 0; j < node.inboundLayers.length; j++) {\r\n                        var inboundLayer = node.inboundLayers[j];\r\n                        var nodeIndex_2 = node.nodeIndices[j];\r\n                        var tensorIndex = node.tensorIndices[j];\r\n                        var shapeKey = inboundLayer.name + \"_\" + nodeIndex_2 + \"_\" + tensorIndex;\r\n                        var inputShape_2 = layersToOutputShapes[shapeKey];\r\n                        inputShapes_1.push(inputShape_2);\r\n                    }\r\n                    var outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes_1));\r\n                    var outputShapes_1 = generic_utils.normalizeShapeList(outputShape);\r\n                    var nodeIndex = layer.inboundNodes.indexOf(node);\r\n                    for (var j = 0; j < outputShapes_1.length; j++) {\r\n                        var shapeKey = layer.name + \"_\" + nodeIndex + \"_\" + j;\r\n                        layersToOutputShapes[shapeKey] = outputShapes_1[j];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var outputShapes = [];\r\n        var outputShapeKeys = [];\r\n        for (var i = 0; i < this.outputLayers.length; i++) {\r\n            var layer = this.outputLayers[i];\r\n            var nodeIndex = this.outputLayersNodeIndices[i];\r\n            var tensorIndex = this.outputLayersTensorIndices[i];\r\n            var shapeKey = layer.name + \"_\" + nodeIndex + \"_\" + tensorIndex;\r\n            outputShapeKeys.push(shapeKey);\r\n        }\r\n        for (var i = 0; i < outputShapeKeys.length; i++) {\r\n            var key = outputShapeKeys[i];\r\n            generic_utils.assert(key in layersToOutputShapes);\r\n            outputShapes.push(layersToOutputShapes[key]);\r\n        }\r\n        return generic_utils.singletonOrArray(outputShapes);\r\n    };\r\n    Container.prototype.runInternalGraph = function (inputs, masks) {\r\n        if (masks == null) {\r\n            masks = generic_utils.pyListRepeat(null, inputs.length);\r\n        }\r\n        var tensorMap = {};\r\n        for (var i = 0; i < this.inputs.length; ++i) {\r\n            var x = this.inputs[i];\r\n            var y = inputs[i];\r\n            var mask = masks[i];\r\n            tensorMap[x.id] = [y, mask];\r\n        }\r\n        var depthKeys = Object.keys(this.nodesByDepth)\r\n            .map(function (x) { return parseInt(x, 10); })\r\n            .sort(generic_utils.reverseNumberCompare);\r\n        for (var _i = 0, depthKeys_4 = depthKeys; _i < depthKeys_4.length; _i++) {\r\n            var depth = depthKeys_4[_i];\r\n            var nodes = this.nodesByDepth[depth];\r\n            for (var _a = 0, nodes_2 = nodes; _a < nodes_2.length; _a++) {\r\n                var node = nodes_2[_a];\r\n                var layer = node.outboundLayer;\r\n                var referenceInputTensors = node.inputTensors;\r\n                var referenceOutputTensors = node.outputTensors;\r\n                var computedData = new Array();\r\n                for (var _b = 0, referenceInputTensors_1 = referenceInputTensors; _b < referenceInputTensors_1.length; _b++) {\r\n                    var x = referenceInputTensors_1[_b];\r\n                    if (x.id in tensorMap) {\r\n                        computedData.push(tensorMap[x.id]);\r\n                    }\r\n                }\r\n                if (computedData.length === referenceInputTensors.length) {\r\n                    var kwargs = {};\r\n                    var computedTensors = void 0;\r\n                    var computedMasks = void 0;\r\n                    var outputTensors_1 = void 0;\r\n                    var outputMasks_1 = void 0;\r\n                    if (node.callArgs != null) {\r\n                        kwargs = node.callArgs;\r\n                    }\r\n                    if (computedData.length === 1) {\r\n                        var _c = computedData[0], computedTensor = _c[0], computedMask = _c[1];\r\n                        if (kwargs.mask == null) {\r\n                            kwargs['mask'] = computedMask;\r\n                        }\r\n                        outputTensors_1 =\r\n                            generic_utils.toList(layer.call(computedTensor, kwargs));\r\n                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensor, computedMask));\r\n                        computedTensors = [computedTensor];\r\n                        computedMasks = [computedMask];\r\n                    }\r\n                    else {\r\n                        computedTensors = computedData.map(function (x) { return x[0]; });\r\n                        computedMasks = computedData.map(function (x) { return x[1]; });\r\n                        if (kwargs.mask == null) {\r\n                            kwargs['mask'] = computedMasks;\r\n                        }\r\n                        outputTensors_1 =\r\n                            generic_utils.toList(layer.call(computedTensors, kwargs));\r\n                        outputMasks_1 = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));\r\n                    }\r\n                    if (layer.activityRegularizer) {\r\n                        throw new NotImplementedError('Model invocation with concrete Tensor value(s) in the ' +\r\n                            'presence of activity regularizer(s) is not supported yet.');\r\n                    }\r\n                    for (var i = 0; i < referenceOutputTensors.length; ++i) {\r\n                        var x = referenceOutputTensors[i];\r\n                        var y = outputTensors_1[i];\r\n                        var mask = outputMasks_1[i];\r\n                        tensorMap[x.id] = [y, mask];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var outputTensors = [];\r\n        var outputMasks = [];\r\n        var outputShapes = [];\r\n        for (var _d = 0, _e = this.outputs; _d < _e.length; _d++) {\r\n            var x = _e[_d];\r\n            generic_utils.assert(x.id in tensorMap, \"Could not compute output \" + x.name + \" : \" + x.id);\r\n            var _f = tensorMap[x.id], tensor = _f[0], mask = _f[1];\r\n            outputShapes.push(tensor.shape);\r\n            outputTensors.push(tensor);\r\n            outputMasks.push(mask);\r\n        }\r\n        return [outputTensors, outputMasks, outputShapes];\r\n    };\r\n    Container.prototype.buildNodeConversionMap = function (layers) {\r\n        var nodeConversionMap = {};\r\n        var keptNodes;\r\n        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            keptNodes = layer instanceof Container ? 1 : 0;\r\n            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\r\n                var nodeKey = Container.nodeKey(layer, originalNodeIndex);\r\n                if (nodeKey in this.containerNodes) {\r\n                    nodeConversionMap[nodeKey] = keptNodes;\r\n                    keptNodes += 1;\r\n                }\r\n            }\r\n        }\r\n        return nodeConversionMap;\r\n    };\r\n    Container.prototype.getLayer = function (name, index) {\r\n        if (index != null) {\r\n            if (this.layers.length <= index) {\r\n                throw new ValueError(\"Was asked to retrieve layer at index \" + index + \", but model only \" +\r\n                    (\"has \" + this.layers.length + \" layer(s).\"));\r\n            }\r\n            else {\r\n                return this.layers[index];\r\n            }\r\n        }\r\n        else {\r\n            if (name == null) {\r\n                throw new ValueError('Provide either a layer name or layer index');\r\n            }\r\n        }\r\n        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            if (layer.name === name) {\r\n                return layer;\r\n            }\r\n        }\r\n        throw new ValueError(\"No such layer: \" + name);\r\n    };\r\n    Container.prototype.calculateLosses = function () {\r\n        var _this = this;\r\n        return tidy(function () {\r\n            var losses = [];\r\n            for (var _i = 0, _a = _this.layers; _i < _a.length; _i++) {\r\n                var layer = _a[_i];\r\n                for (var nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {\r\n                    var nodeKey = Container.nodeKey(layer, nodeIndex);\r\n                    if (_this.containerNodes.has(nodeKey)) {\r\n                        losses.push.apply(losses, layer.calculateLosses());\r\n                    }\r\n                }\r\n            }\r\n            return losses;\r\n        });\r\n    };\r\n    Container.prototype.getConfig = function () {\r\n        var config = { name: this.name };\r\n        var nodeConversionMap = this.buildNodeConversionMap(this.layers);\r\n        var layerConfigs = [];\r\n        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n            var layer = _a[_i];\r\n            var layerClassName = layer.getClassName();\r\n            var layerConfig = layer.getConfig();\r\n            var filteredInboundNodes = [];\r\n            for (var originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\r\n                var node = layer.inboundNodes[originalNodeIndex];\r\n                var nodeKey = Container.nodeKey(layer, originalNodeIndex);\r\n                var kwargs = {};\r\n                if (this.containerNodes.has(nodeKey)) {\r\n                    if (node.callArgs) {\r\n                        var testString = JSON.stringify(node.callArgs);\r\n                        if (testString.indexOf('undefined') === -1) {\r\n                            kwargs = node.callArgs;\r\n                        }\r\n                        else {\r\n                            console.warn(\"Layer \" + layer.name + \" was passed \" +\r\n                                \"non-serializable keyword arguments: \" +\r\n                                (node.callArgs + \". They will not be included \") +\r\n                                \"in the serialized model (and thus will be \" +\r\n                                \"missing at deserialization time).\");\r\n                            kwargs = {};\r\n                        }\r\n                    }\r\n                    if (node.inboundLayers.length > 0) {\r\n                        var nodeData = [];\r\n                        for (var i = 0; i < node.inboundLayers.length; i++) {\r\n                            var inboundLayer = node.inboundLayers[i];\r\n                            var nodeIndex = node.nodeIndices[i];\r\n                            var tensorIndex = node.tensorIndices[i];\r\n                            var nodeKey_1 = Container.nodeKey(inboundLayer, nodeIndex);\r\n                            var newNodeIndex = nodeConversionMap[nodeKey_1];\r\n                            if (newNodeIndex === null || newNodeIndex === undefined) {\r\n                                newNodeIndex = 0;\r\n                            }\r\n                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);\r\n                        }\r\n                        filteredInboundNodes.push(nodeData);\r\n                    }\r\n                }\r\n            }\r\n            layerConfigs.push({\r\n                name: layer.name,\r\n                className: layerClassName,\r\n                config: layerConfig,\r\n                inboundNodes: filteredInboundNodes\r\n            });\r\n        }\r\n        config['layers'] = layerConfigs;\r\n        var modelInputs = [];\r\n        for (var i = 0; i < this.inputLayers.length; i++) {\r\n            var layer = this.inputLayers[i];\r\n            var nodeIndex = this.inputLayersNodeIndices[i];\r\n            var nodeKey = Container.nodeKey(layer, nodeIndex);\r\n            if (!this.containerNodes.has(nodeKey)) {\r\n                continue;\r\n            }\r\n            var newNodeIndex = nodeConversionMap[nodeKey];\r\n            if (newNodeIndex === null || newNodeIndex === undefined) {\r\n                newNodeIndex = 0;\r\n            }\r\n            var tensorIndex = this.inputLayersTensorIndices[i];\r\n            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);\r\n        }\r\n        config['inputLayers'] = modelInputs;\r\n        var modelOutputs = [];\r\n        for (var i = 0; i < this.outputLayers.length; i++) {\r\n            var layer = this.outputLayers[i];\r\n            var nodeIndex = this.outputLayersNodeIndices[i];\r\n            var nodeKey = Container.nodeKey(layer, nodeIndex);\r\n            if (!this.containerNodes.has(nodeKey)) {\r\n                continue;\r\n            }\r\n            var newNodeIndex = nodeConversionMap[nodeKey];\r\n            if (newNodeIndex === null || newNodeIndex === undefined) {\r\n                newNodeIndex = 0;\r\n            }\r\n            var tensorIndex = this.outputLayersTensorIndices[i];\r\n            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);\r\n        }\r\n        config['outputLayers'] = modelOutputs;\r\n        return config;\r\n    };\r\n    Container.fromConfig = function (cls, config) {\r\n        var createdLayers = {};\r\n        var unprocessedNodes = {};\r\n        function addUnprocessedNode(layer, nodeData) {\r\n            if (!(layer.name in unprocessedNodes)) {\r\n                unprocessedNodes[layer.name] = [nodeData];\r\n            }\r\n            else {\r\n                unprocessedNodes[layer.name].push(nodeData);\r\n            }\r\n        }\r\n        function processNode(layer, nodeData) {\r\n            var inputTensors = [];\r\n            var kwargs;\r\n            for (var _i = 0, nodeData_1 = nodeData; _i < nodeData_1.length; _i++) {\r\n                var inputData = nodeData_1[_i];\r\n                var inboundLayerName = inputData[0];\r\n                var inboundNodeIndex = inputData[1];\r\n                var inboundTensorIndex = inputData[2];\r\n                if (inputData.length === 3) {\r\n                    kwargs = {};\r\n                }\r\n                else if (inputData.length === 4) {\r\n                    kwargs = inputData[3];\r\n                }\r\n                else {\r\n                    throw new ValueError(\"Improperly formatted model config for layer \" + JSON.stringify(layer) + \": \" + JSON.stringify(inputData));\r\n                }\r\n                if (!(inboundLayerName in createdLayers)) {\r\n                    addUnprocessedNode(layer, nodeData);\r\n                    return;\r\n                }\r\n                var inboundLayer = createdLayers[inboundLayerName];\r\n                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {\r\n                    addUnprocessedNode(layer, nodeData);\r\n                    return;\r\n                }\r\n                var inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];\r\n                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);\r\n            }\r\n            if (inputTensors.length > 0) {\r\n                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs);\r\n            }\r\n        }\r\n        function processLayer(layerData) {\r\n            var layerName = layerData.name;\r\n            var layer = deserializeLayer(layerData, config.customObjects != null ?\r\n                config.customObjects :\r\n                {});\r\n            createdLayers[layerName] = layer;\r\n            var inboundNodesData = layerData.inboundNodes;\r\n            for (var _i = 0, inboundNodesData_1 = inboundNodesData; _i < inboundNodesData_1.length; _i++) {\r\n                var nodeData = inboundNodesData_1[_i];\r\n                if (!(nodeData instanceof Array)) {\r\n                    throw new ValueError(\"Corrupted configuration, expected array for nodeData: \" + nodeData);\r\n                }\r\n                addUnprocessedNode(layer, nodeData);\r\n            }\r\n        }\r\n        var name = config.name;\r\n        var layersFromConfig = config.layers;\r\n        for (var _i = 0, layersFromConfig_1 = layersFromConfig; _i < layersFromConfig_1.length; _i++) {\r\n            var layerData = layersFromConfig_1[_i];\r\n            processLayer(layerData);\r\n        }\r\n        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {\r\n            for (var _a = 0, layersFromConfig_2 = layersFromConfig; _a < layersFromConfig_2.length; _a++) {\r\n                var layerData = layersFromConfig_2[_a];\r\n                var layer = createdLayers[layerData.name];\r\n                if (layer.name in unprocessedNodes) {\r\n                    for (var _b = 0, _c = unprocessedNodes[layer.name]; _b < _c.length; _b++) {\r\n                        var nodeData = _c[_b];\r\n                        processNode(layer, nodeData);\r\n                    }\r\n                    delete unprocessedNodes[layer.name];\r\n                }\r\n            }\r\n        }\r\n        var inputTensors = [];\r\n        var outputTensors = [];\r\n        var inputLayersFromConfig = config.inputLayers;\r\n        for (var _d = 0, inputLayersFromConfig_1 = inputLayersFromConfig; _d < inputLayersFromConfig_1.length; _d++) {\r\n            var layerData = inputLayersFromConfig_1[_d];\r\n            var layerName = layerData[0];\r\n            var nodeIndex = layerData[1];\r\n            var tensorIndex = layerData[2];\r\n            generic_utils.assert(layerName in createdLayers);\r\n            var layer = createdLayers[layerName];\r\n            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\r\n            inputTensors.push(layerOutputTensors[tensorIndex]);\r\n        }\r\n        var outputLayersFromConfig = config.outputLayers;\r\n        for (var _e = 0, outputLayersFromConfig_1 = outputLayersFromConfig; _e < outputLayersFromConfig_1.length; _e++) {\r\n            var layerData = outputLayersFromConfig_1[_e];\r\n            var layerName = layerData[0];\r\n            var nodeIndex = layerData[1];\r\n            var tensorIndex = layerData[2];\r\n            generic_utils.assert(layerName in createdLayers);\r\n            var layer = createdLayers[layerName];\r\n            var layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\r\n            outputTensors.push(layerOutputTensors[tensorIndex]);\r\n        }\r\n        return new cls({ inputs: inputTensors, outputs: outputTensors, name: name });\r\n    };\r\n    Object.defineProperty(Container.prototype, \"stateful\", {\r\n        get: function () {\r\n            if (this._stateful) {\r\n                throw new ValueError('Container instance unexpectedly has _stateful = true. The ' +\r\n                    'statefulness of a Container is determined by the Layers it ' +\r\n                    'contains. Its _stateful property must remain the default false.');\r\n            }\r\n            for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\r\n                var layer = _a[_i];\r\n                if (layer.stateful) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    tslib_1.__decorate([\r\n        doc({\r\n            heading: 'Layers',\r\n            subheading: 'Classes',\r\n            namespace: 'layers',\r\n            subclasses: ['Model']\r\n        })\r\n    ], Container.prototype, \"getLayer\", null);\r\n    return Container;\r\n}(Layer));\r\nexport { Container };\r\nexport function getSourceInputs(tensor, layer, nodeIndex) {\r\n    if (layer == null || (nodeIndex != null && nodeIndex > 0)) {\r\n        layer = tensor.sourceLayer;\r\n        nodeIndex = tensor.nodeIndex;\r\n    }\r\n    if (layer.inboundNodes.length === 0) {\r\n        return [tensor];\r\n    }\r\n    else {\r\n        var node = layer.inboundNodes[nodeIndex];\r\n        if (node.inboundLayers.length === 0) {\r\n            return node.inputTensors;\r\n        }\r\n        else {\r\n            var sourceTensors = [];\r\n            for (var i = 0; i < node.inboundLayers.length; i++) {\r\n                var x = node.inputTensors[i];\r\n                var layer_2 = node.inboundLayers[i];\r\n                var nodeIndex_3 = node.nodeIndices[i];\r\n                var previousSources = getSourceInputs(x, layer_2, nodeIndex_3);\r\n                for (var _i = 0, previousSources_1 = previousSources; _i < previousSources_1.length; _i++) {\r\n                    var x_1 = previousSources_1[_i];\r\n                    if (sourceTensors.indexOf(x_1) === -1) {\r\n                        sourceTensors.push(x_1);\r\n                    }\r\n                }\r\n            }\r\n            return sourceTensors;\r\n        }\r\n    }\r\n}\r\nfunction loadTensor(dtype, shape, value) {\r\n    var dataType = generic_utils.stringToDType(dtype);\r\n    return Tensor.make(shape, { values: shape.length === 0 ? value : util.flatten(value) }, dataType);\r\n}\r\nfunction preprocessWeightsForLoading(layer, weights, originalKerasVersion, originalBackend) {\r\n    if (!originalKerasVersion.startsWith('2.')) {\r\n        throw new ValueError('Unsupported Keras version in weights being loaded: ' +\r\n            originalKerasVersion);\r\n    }\r\n    return weights;\r\n}\r\nexport function loadWeightsFromNamedTensorMap(weights, layers) {\r\n    var nameToWeight = {};\r\n    var totalWeightsCount = 0;\r\n    for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {\r\n        var layer = layers_1[_i];\r\n        for (var _a = 0, _b = layer.weights; _a < _b.length; _a++) {\r\n            var weight = _b[_a];\r\n            if (nameToWeight[weight.originalName] != null) {\r\n                throw new ValueError(\"Duplicate weight name: \" + weight.originalName);\r\n            }\r\n            nameToWeight[weight.originalName] = weight;\r\n            totalWeightsCount++;\r\n        }\r\n    }\r\n    var weightValueTuples = [];\r\n    for (var name_2 in weights) {\r\n        weightValueTuples.push([nameToWeight[name_2], weights[name_2]]);\r\n        delete nameToWeight[name_2];\r\n    }\r\n    var unsetNames = [];\r\n    for (var name_3 in nameToWeight) {\r\n        unsetNames.push(name_3);\r\n    }\r\n    if (unsetNames.length > 0) {\r\n        throw new ValueError(unsetNames.length + \" of \" + totalWeightsCount + \" weights are not set: \" +\r\n            (\"\" + unsetNames));\r\n    }\r\n    batchSetValue(weightValueTuples);\r\n}\r\nexport function loadWeightsFromJson(weightsJSON, layers, skipMismatch) {\r\n    if (skipMismatch === void 0) { skipMismatch = false; }\r\n    var originalKerasVersion = weightsJSON['keras_version'];\r\n    var originalBackend = weightsJSON['backend'];\r\n    var layerNames = layers.map(function (layer) { return layer.name; });\r\n    var index = {};\r\n    for (var _i = 0, layers_2 = layers; _i < layers_2.length; _i++) {\r\n        var layer = layers_2[_i];\r\n        if (layer.name != null) {\r\n            if (index[layer.name] == null) {\r\n                index[layer.name] = [];\r\n            }\r\n            index[layer.name].push(layer);\r\n        }\r\n    }\r\n    var nameToWeights = weightsJSON['weights'];\r\n    var weightValueTuples = [];\r\n    for (var k = 0; k < layerNames.length; ++k) {\r\n        var name_4 = layerNames[k];\r\n        var layerWeights = nameToWeights[name_4];\r\n        if (layerWeights == null) {\r\n            layerWeights = [];\r\n        }\r\n        var weightValues = [];\r\n        for (var n = 0; n < layerWeights.length; ++n) {\r\n            var weightEntry = layerWeights[n];\r\n            weightValues.push(new LayerVariable(loadTensor(weightEntry['dtype'], weightEntry['shape'], weightEntry['value'])));\r\n        }\r\n        for (var _a = 0, _b = index[name_4]; _a < _b.length; _a++) {\r\n            var layer = _b[_a];\r\n            var symbolicWeights = layer.weights;\r\n            weightValues = preprocessWeightsForLoading(layer, weightValues, originalKerasVersion, originalBackend);\r\n            if (weightValues.length !== symbolicWeights.length) {\r\n                if (skipMismatch) {\r\n                    console.warn(\"Skipping loading of weights of layer \" + layer.name + \" \" +\r\n                        (\"due to mismatch in number of weights: (\" + weightValues.length + \" \") +\r\n                        (\"vs \" + symbolicWeights.length + \").\"));\r\n                }\r\n                else {\r\n                    throw new ValueError(\"Layer #\" + k + \" (named \\\"\" + layer.name + \"\\\") expects \" +\r\n                        (symbolicWeights.length + \" weight(s), but the saved weights \") +\r\n                        (\"have \" + weightValues.length + \" element(s).\"));\r\n                }\r\n            }\r\n            for (var i = 0; i < weightValues.length; ++i) {\r\n                if (skipMismatch) {\r\n                    if (!util.arraysEqual(symbolicWeights[i].shape, weightValues[i].shape)) {\r\n                        console.warn(\"Skipping loading of weights for layer \" + layer.name + \" due \" +\r\n                            (\"to mismatch in shape (\" + symbolicWeights[i].shape + \" vs \") +\r\n                            (weightValues[i].shape + \")\"));\r\n                        continue;\r\n                    }\r\n                }\r\n                weightValueTuples.push([symbolicWeights[i], weightValues[i].read()]);\r\n            }\r\n        }\r\n    }\r\n    batchSetValue(weightValueTuples);\r\n}\r\n//# sourceMappingURL=topology.js.map","map":"{\"version\":3,\"file\":\"topology.js\",\"sourceRoot\":\"\",\"sources\":[\"../src/engine/topology.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/smilkov/code/tfjs-layers/engine/topology.d.ts","text":"import { DataType, Scalar, serialization, Tensor } from '@tensorflow/tfjs-core';\r\nimport { Constraint } from '../constraints';\r\nimport { Initializer } from '../initializers';\r\nimport { Regularizer } from '../regularizers';\r\nimport { JsonDict, Kwargs, NamedTensorMap, RegularizerFn, Shape, SymbolicTensor } from '../types';\r\nimport { LayerVariable } from '../variables';\r\nexport declare type Op = (x: LayerVariable) => LayerVariable;\r\nexport interface InputSpecConfig {\r\n    dtype?: DataType;\r\n    shape?: Shape;\r\n    ndim?: number;\r\n    maxNDim?: number;\r\n    minNDim?: number;\r\n    axes?: {\r\n        [axis: number]: number;\r\n    };\r\n}\r\nexport declare class InputSpec {\r\n    dtype?: DataType;\r\n    shape?: Shape;\r\n    ndim?: number;\r\n    maxNDim?: number;\r\n    minNDim?: number;\r\n    axes?: {\r\n        [axis: number]: number;\r\n    };\r\n    constructor(config: InputSpecConfig);\r\n}\r\nexport interface NodeConfig {\r\n    outboundLayer: Layer;\r\n    inboundLayers: Layer[];\r\n    nodeIndices: number[];\r\n    tensorIndices: number[];\r\n    inputTensors: SymbolicTensor[];\r\n    outputTensors: SymbolicTensor[];\r\n    inputMasks: Tensor[];\r\n    outputMasks: Tensor[];\r\n    inputShapes: Shape | Shape[];\r\n    outputShapes: Shape | Shape[];\r\n}\r\nexport declare class Node {\r\n    callArgs: Kwargs;\r\n    outboundLayer: Layer;\r\n    inboundLayers: Layer[];\r\n    nodeIndices: number[];\r\n    tensorIndices: number[];\r\n    inputTensors: SymbolicTensor[];\r\n    outputTensors: SymbolicTensor[];\r\n    inputMasks: Tensor[];\r\n    outputMasks: Tensor[];\r\n    inputShapes: Shape | Shape[];\r\n    outputShapes: Shape | Shape[];\r\n    readonly id: number;\r\n    constructor(config: NodeConfig, callArgs?: Kwargs);\r\n    getConfig(): serialization.ConfigDict;\r\n}\r\nexport interface LayerConfig {\r\n    inputShape?: Shape;\r\n    batchInputShape?: Shape;\r\n    batchSize?: number;\r\n    dtype?: DataType;\r\n    name?: string;\r\n    trainable?: boolean;\r\n    updatable?: boolean;\r\n    weights?: Tensor[];\r\n    inputDType?: DataType;\r\n}\r\nexport declare type CallHook = (inputs: Tensor | Tensor[], kwargs: Kwargs) => void;\r\nexport declare abstract class Layer extends serialization.Serializable {\r\n    name: string;\r\n    inputSpec: InputSpec[];\r\n    supportsMasking: boolean;\r\n    trainable: boolean;\r\n    updatable: boolean;\r\n    batchInputShape: Shape;\r\n    dtype: DataType;\r\n    initialWeights: Tensor[];\r\n    inboundNodes: Node[];\r\n    outboundNodes: Node[];\r\n    activityRegularizer: Regularizer;\r\n    protected _trainableWeights: LayerVariable[];\r\n    private _nonTrainableWeights;\r\n    private _losses;\r\n    private _updates;\r\n    private _built;\r\n    private _callHook;\r\n    private _addedWeightNames;\r\n    readonly id: number;\r\n    protected _stateful: boolean;\r\n    constructor(config: LayerConfig);\r\n    protected static nodeKey(layer: Layer, nodeIndex: number): string;\r\n    private getNodeAtIndex(nodeIndex, attrName);\r\n    getInputAt(nodeIndex: number): SymbolicTensor | SymbolicTensor[];\r\n    getOutputAt(nodeIndex: number): SymbolicTensor | SymbolicTensor[];\r\n    readonly input: SymbolicTensor | SymbolicTensor[];\r\n    readonly output: SymbolicTensor | SymbolicTensor[];\r\n    readonly losses: RegularizerFn[];\r\n    calculateLosses(): Scalar[];\r\n    readonly updates: Tensor[];\r\n    built: boolean;\r\n    trainableWeights: LayerVariable[];\r\n    nonTrainableWeights: LayerVariable[];\r\n    readonly weights: LayerVariable[];\r\n    readonly stateful: boolean;\r\n    protected assertInputCompatibility(inputs: Tensor | Tensor[] | SymbolicTensor | SymbolicTensor[]): void;\r\n    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];\r\n    protected invokeCallHook(inputs: Tensor | Tensor[], kwargs: Kwargs): void;\r\n    setCallHook(callHook: CallHook): void;\r\n    clearCallHook(): void;\r\n    apply(inputs: Tensor | Tensor[] | SymbolicTensor | SymbolicTensor[], kwargs?: Kwargs): Tensor | Tensor[] | SymbolicTensor | SymbolicTensor[];\r\n    build(inputShape: Shape | Shape[]): void;\r\n    getWeights(trainableOnly?: boolean): Tensor[];\r\n    setWeights(weights: Tensor[]): void;\r\n    protected addWeight(name: string, shape: Shape, dtype?: DataType, initializer?: Initializer, regularizer?: Regularizer, trainable?: boolean, constraint?: Constraint): LayerVariable;\r\n    addLoss(losses: RegularizerFn | RegularizerFn[]): void;\r\n    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];\r\n    computeMask(inputs: Tensor | Tensor[], mask?: Tensor | Tensor[]): Tensor | Tensor[];\r\n    private addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs?);\r\n    getConfig(): serialization.ConfigDict;\r\n}\r\nexport interface InputLayerConfig {\r\n    inputShape?: Shape;\r\n    batchSize?: number;\r\n    batchInputShape?: Shape;\r\n    dtype?: DataType;\r\n    sparse?: boolean;\r\n    name?: string;\r\n}\r\nexport declare class InputLayer extends Layer {\r\n    static readonly className: string;\r\n    sparse: boolean;\r\n    constructor(config: InputLayerConfig);\r\n    apply(inputs: Tensor | Tensor[] | SymbolicTensor | SymbolicTensor[], kwargs?: Kwargs): Tensor | Tensor[] | SymbolicTensor;\r\n    getConfig(): serialization.ConfigDict;\r\n}\r\nexport interface InputConfig {\r\n    shape?: Shape;\r\n    batchShape?: Shape;\r\n    name?: string;\r\n    dtype?: DataType;\r\n    sparse?: boolean;\r\n}\r\nexport declare function Input(config: InputConfig): SymbolicTensor;\r\nexport interface ContainerConfig {\r\n    inputs: SymbolicTensor | SymbolicTensor[];\r\n    outputs: SymbolicTensor | SymbolicTensor[];\r\n    name?: string;\r\n}\r\nexport declare abstract class Container extends Layer {\r\n    inputs: SymbolicTensor[];\r\n    outputs: SymbolicTensor[];\r\n    inputLayers: Layer[];\r\n    inputLayersNodeIndices: number[];\r\n    inputLayersTensorIndices: number[];\r\n    outputLayers: Layer[];\r\n    outputLayersNodeIndices: number[];\r\n    outputLayersTensorIndices: number[];\r\n    layers: Layer[];\r\n    layersByDepth: {\r\n        [depth: string]: Layer[];\r\n    };\r\n    nodesByDepth: {\r\n        [depth: string]: Node[];\r\n    };\r\n    containerNodes: Set<string>;\r\n    inputNames: string[];\r\n    outputNames: string[];\r\n    feedInputShapes: Shape[];\r\n    protected internalInputShapes: Shape[];\r\n    protected internalOutputShapes: Shape[];\r\n    protected feedInputNames: string[];\r\n    protected feedOutputNames: string[];\r\n    constructor(config: ContainerConfig);\r\n    readonly trainableWeights: LayerVariable[];\r\n    readonly nonTrainableWeights: LayerVariable[];\r\n    readonly weights: LayerVariable[];\r\n    loadWeights(weightsJSON: JsonDict | NamedTensorMap, skipMismatch?: boolean, isNamedTensorMap?: boolean): void;\r\n    private updatedConfig();\r\n    toJSON(unused?: any, returnString?: boolean): string | JsonDict;\r\n    call(inputs: Tensor | Tensor[], kwargs: Kwargs): Tensor | Tensor[];\r\n    computeMask(inputs: Tensor | Tensor[], mask?: Tensor | Tensor[]): Tensor | Tensor[];\r\n    computeOutputShape(inputShape: Shape | Shape[]): Shape | Shape[];\r\n    protected runInternalGraph(inputs: Tensor[], masks?: Tensor[]): [Tensor[], Tensor[], Shape[]];\r\n    private buildNodeConversionMap(layers);\r\n    getLayer(name?: string, index?: number): Layer;\r\n    calculateLosses(): Scalar[];\r\n    getConfig(): serialization.ConfigDict;\r\n    static fromConfig<T extends serialization.Serializable>(cls: serialization.SerializableConstructor<T>, config: serialization.ConfigDict): T;\r\n    readonly stateful: boolean;\r\n}\r\nexport declare function getSourceInputs(tensor: SymbolicTensor, layer?: Layer, nodeIndex?: number): SymbolicTensor[];\r\nexport declare function loadWeightsFromNamedTensorMap(weights: NamedTensorMap, layers: Layer[]): void;\r\nexport declare function loadWeightsFromJson(weightsJSON: JsonDict, layers: Layer[], skipMismatch?: boolean): void;\r\n"}}
