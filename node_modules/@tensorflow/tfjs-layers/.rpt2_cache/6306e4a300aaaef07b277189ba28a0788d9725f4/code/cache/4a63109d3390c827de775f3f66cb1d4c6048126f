{"code":"import { checkStringTypeUnionValue } from './utils/generic_utils';\r\nvar nameMap = new Map();\r\nexport var VALID_DATA_FORMAT_VALUES = ['channelsFirst', 'channelsLast'];\r\nexport function checkDataFormat(value) {\r\n    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\r\n}\r\nexport var VALID_PADDING_MODE_VALUES = ['valid', 'same', 'causal'];\r\nexport function checkPaddingMode(value) {\r\n    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\r\n}\r\nexport var VALID_POOL_MODE_VALUES = ['max', 'avg'];\r\nexport function checkPoolMode(value) {\r\n    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\r\n}\r\nvar _nameScopeStack = [];\r\nvar _nameScopeDivider = '/';\r\nexport function nameScope(name, fn) {\r\n    _nameScopeStack.push(name);\r\n    try {\r\n        var val = fn();\r\n        _nameScopeStack.pop();\r\n        return val;\r\n    }\r\n    catch (e) {\r\n        _nameScopeStack.pop();\r\n        throw e;\r\n    }\r\n}\r\nfunction currentNameScopePrefix() {\r\n    if (_nameScopeStack.length === 0) {\r\n        return '';\r\n    }\r\n    else {\r\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\r\n    }\r\n}\r\nexport function getScopedTensorName(tensorName) {\r\n    if (!isValidTensorName(tensorName)) {\r\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\r\n    }\r\n    return currentNameScopePrefix() + tensorName;\r\n}\r\nexport function getUniqueTensorName(scopedName) {\r\n    if (!isValidTensorName(scopedName)) {\r\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\r\n    }\r\n    if (!nameMap.has(scopedName)) {\r\n        nameMap.set(scopedName, 0);\r\n    }\r\n    var index = nameMap.get(scopedName);\r\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\r\n    if (index > 0) {\r\n        var result = scopedName + '_' + index;\r\n        nameMap.set(result, 1);\r\n        return result;\r\n    }\r\n    else {\r\n        return scopedName;\r\n    }\r\n}\r\nvar tensorNameRegex = new RegExp(/^[A-Za-z][A-Za-z0-9\\._\\/]*$/);\r\nexport function isValidTensorName(name) {\r\n    return name.match(tensorNameRegex) ? true : false;\r\n}\r\n//# sourceMappingURL=common.js.map","map":"{\"version\":3,\"file\":\"common.js\",\"sourceRoot\":\"\",\"sources\":[\"src/common.ts\"],\"names\":[],\"mappings\":\"AAaA,OAAO,EAAC,yBAAyB,EAAC,MAAM,uBAAuB,CAAC;AAIhE,IAAM,OAAO,GAAwB,IAAI,GAAG,EAAkB,CAAC;AAM/D,MAAM,CAAC,IAAM,wBAAwB,GAAG,CAAC,eAAe,EAAE,cAAc,CAAC,CAAC;AAC1E,MAAM,0BAA0B,KAAc;IAC5C,yBAAyB,CAAC,wBAAwB,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;AAC3E,CAAC;AAID,MAAM,CAAC,IAAM,yBAAyB,GAAG,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;AACrE,MAAM,2BAA2B,KAAc;IAC7C,yBAAyB,CAAC,yBAAyB,EAAE,aAAa,EAAE,KAAK,CAAC,CAAC;AAC7E,CAAC;AAID,MAAM,CAAC,IAAM,sBAAsB,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AACrD,MAAM,wBAAwB,KAAc;IAC1C,yBAAyB,CAAC,sBAAsB,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;AACvE,CAAC;AAED,IAAM,eAAe,GAAa,EAAE,CAAC;AACrC,IAAM,iBAAiB,GAAG,GAAG,CAAC;AAK9B,MAAM,oBAAuB,IAAY,EAAE,EAAW;IACpD,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC3B,IAAI;QACF,IAAM,GAAG,GAAM,EAAE,EAAE,CAAC;QACpB,eAAe,CAAC,GAAG,EAAE,CAAC;QACtB,OAAO,GAAG,CAAC;KACZ;IAAC,OAAO,CAAC,EAAE;QACV,eAAe,CAAC,GAAG,EAAE,CAAC;QACtB,MAAM,CAAC,CAAC;KACT;AACH,CAAC;AAKD;IACE,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;QAChC,OAAO,EAAE,CAAC;KACX;SAAM;QACL,OAAO,eAAe,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,CAAC;KACpE;AACH,CAAC;AAOD,MAAM,8BAA8B,UAAkB;IACpD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;KACpE;IACD,OAAO,sBAAsB,EAAE,GAAG,UAAU,CAAC;AAC/C,CAAC;AAYD,MAAM,8BAA8B,UAAkB;IACpD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAE;QAClC,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;KACpE;IACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;QAC5B,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;KAC5B;IACD,IAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACtC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;IAErD,IAAI,KAAK,GAAG,CAAC,EAAE;QACb,IAAM,MAAM,GAAG,UAAU,GAAG,GAAG,GAAG,KAAK,CAAC;QAGxC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACvB,OAAO,MAAM,CAAC;KACf;SAAM;QACL,OAAO,UAAU,CAAC;KACnB;AACH,CAAC;AAED,IAAM,eAAe,GAAG,IAAI,MAAM,CAAC,6BAA6B,CAAC,CAAC;AAOlE,MAAM,4BAA4B,IAAY;IAC5C,OAAO,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;AACpD,CAAC\"}","dts":{"name":"/usr/local/google/home/smilkov/code/tfjs-layers/common.d.ts","text":"export declare type DataFormat = 'channelsFirst' | 'channelsLast';\r\nexport declare const VALID_DATA_FORMAT_VALUES: string[];\r\nexport declare function checkDataFormat(value?: string): void;\r\nexport declare type PaddingMode = 'valid' | 'same' | 'causal';\r\nexport declare const VALID_PADDING_MODE_VALUES: string[];\r\nexport declare function checkPaddingMode(value?: string): void;\r\nexport declare type PoolMode = 'max' | 'avg';\r\nexport declare const VALID_POOL_MODE_VALUES: string[];\r\nexport declare function checkPoolMode(value?: string): void;\r\nexport declare function nameScope<T>(name: string, fn: () => T): T;\r\nexport declare function getScopedTensorName(tensorName: string): string;\r\nexport declare function getUniqueTensorName(scopedName: string): string;\r\nexport declare function isValidTensorName(name: string): boolean;\r\n"}}
